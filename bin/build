#!/bin/bash
# Build Rust app: install Rust if needed, cargo build (release or debug), copy binary to output.
set -e

# Lifecycle sets these; use standard build container paths when unset (e.g. some platforms).
BUILD_DIR="${CNB_BUILD_DIR:-/workspace}"
LAYERS_DIR="${CNB_LAYERS_DIR:-/layers}"
OUTPUT_DIR="${CNB_OUTPUT_DIR:-/workspace}"
PLAN_PATH="${CNB_PLAN_PATH:-/dev/null}"

if [[ ! -d "${BUILD_DIR}" ]]; then
  echo "CNB_BUILD_DIR (${BUILD_DIR}) is not a directory" >&2
  exit 1
fi

echo "Octopilot Rust Buildpack"
WORKSPACE_DIR="${BP_RUST_WORKSPACE_DIR:-.}"
MANIFEST_PATH="${BUILD_DIR}/${WORKSPACE_DIR}/Cargo.toml"

# Host-aware target: when BP_RUST_TARGET is unset, use native container arch so we don't
# cross-compile (e.g. avoid x86_64 on aarch64 which causes "cc: error: unrecognized option '-m64'").
if [[ -n "${BP_RUST_TARGET:-}" ]]; then
  TARGET="${BP_RUST_TARGET}"
else
  arch=$(uname -m 2>/dev/null || echo unknown)
  case "${arch}" in
    x86_64|amd64) TARGET="x86_64-unknown-linux-gnu" ;;
    aarch64|arm64) TARGET="aarch64-unknown-linux-gnu" ;;
    armv7l|armv6l) TARGET="armv7-unknown-linux-gnueabihf" ;;
    *) TARGET="x86_64-unknown-linux-gnu" ;;  # fallback for unknown
  esac
fi

PACKAGE="${BP_RUST_PACKAGE:-}"
BINARY_NAME="${BP_RUST_BINARY_NAME:-}"
# Monolith mode: build all workspace binaries into one image (default when workspace and no BP_RUST_PACKAGE)
WORKSPACE_MODE="${BP_RUST_WORKSPACE_MODE:-all}"
FEATURES="${BP_RUST_FEATURES:-}"

# Build profile: release (default) or debug (faster compile, larger/slower binary)
case "${BP_RUST_BUILD_PROFILE:-release}" in
  debug|false|0) PROFILE="debug" ;;
  release|true|1) PROFILE="release" ;;
  *) PROFILE="release" ;;
esac

# Toolchain: build+cache only (NOT exported to run image - saves ~1.5GB)
RUST_TOOLCHAIN_LAYER="${LAYERS_DIR}/rust-toolchain"
RUSTUP_HOME="${RUST_TOOLCHAIN_LAYER}/rustup"
CARGO_HOME="${RUST_TOOLCHAIN_LAYER}/cargo"
export RUSTUP_HOME CARGO_HOME
export PATH="${CARGO_HOME}/bin:${PATH}"

# Install Rust into build-only layer (reused on cache)
if [[ ! -x "${CARGO_HOME}/bin/cargo" ]]; then
  echo "Installing Rust..."
  mkdir -p "${RUST_TOOLCHAIN_LAYER}"
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable --no-modify-path
  rustup target add "${TARGET}" 2>/dev/null || true
fi

# Mark toolchain as build+cache only (excluded from final image)
cat > "${LAYERS_DIR}/rust-toolchain.toml" << 'TOML'
[types]
build = true
cache = true
launch = false
TOML

# Build args: profile (release or debug), optional target, optional -p, optional --features
EXTRA_ARGS=("--manifest-path" "${MANIFEST_PATH}")
if [[ "$PROFILE" == "release" ]]; then
  EXTRA_ARGS+=(--release)
fi
if [[ -n "$TARGET" ]]; then
  EXTRA_ARGS+=(--target "$TARGET")
fi
if [[ -n "$PACKAGE" ]]; then
  EXTRA_ARGS+=(-p "$PACKAGE")
fi
if [[ -n "$FEATURES" ]]; then
  EXTRA_ARGS+=(--features "$FEATURES")
fi
# armv7: jemalloc not supported; disable default features for that target
if [[ "$TARGET" == "armv7-unknown-linux-musleabihf" ]]; then
  EXTRA_ARGS+=(--no-default-features)
fi

# Monolith: build all workspace binaries (no -p). Single: build one package.
MONOLITH=false
if [[ -z "$PACKAGE" && "$WORKSPACE_MODE" == "all" ]]; then
  MONOLITH=true
fi

# Build from app root so relative paths in Cargo.toml resolve
cd "${BUILD_DIR}"

# Collect binaries: monolith = all executables, single = one
BINARIES=()
while IFS= read -r line; do
  if [[ "$line" == *'"reason":"compiler-artifact"'* && "$line" == *'"executable":'* ]]; then
    exe=$(echo "$line" | sed -n 's/.*"executable":"\([^"]*\)".*/\1/p')
    if [[ -n "$exe" && -f "$exe" ]]; then
      if [[ "$MONOLITH" == true ]]; then
        BINARIES+=("$exe")
      elif [[ -n "$PACKAGE" ]]; then
        if [[ "$line" == *"\"${PACKAGE}\""* ]]; then
          BINARIES=("$exe")
          break
        fi
      else
        BINARIES=("$exe")
        break
      fi
    fi
  fi
done < <(cargo build "${EXTRA_ARGS[@]}" --message-format=json 2>/dev/null || true)

# Fallback: locate binary(ies) in profile dir
MANIFEST_DIR="$(dirname "${MANIFEST_PATH}")"
TARGET_DIR="${MANIFEST_DIR}/target"
PROFILE_DIR="${TARGET_DIR}/${TARGET}/${PROFILE}"
if [[ ! -d "${PROFILE_DIR}" ]]; then
  PROFILE_DIR="${TARGET_DIR}/${PROFILE}"
fi

if [[ ${#BINARIES[@]} -eq 0 ]]; then
  if [[ "$MONOLITH" == true ]]; then
    # Find all executables (exclude .so, .rlib)
    while IFS= read -r exe; do
      [[ -n "$exe" && -f "$exe" ]] && BINARIES+=("$exe")
    done < <(find "${PROFILE_DIR}" -maxdepth 1 -type f -executable ! -name "*.so" ! -name "*.rlib" 2>/dev/null)
  else
    if [[ -n "$BINARY_NAME" ]]; then
      BINARIES=("${PROFILE_DIR}/${BINARY_NAME}")
    elif [[ -n "$PACKAGE" ]]; then
      try_name=$(echo "$PACKAGE" | tr '-' '_')
      found=$(find "${PROFILE_DIR}" -maxdepth 1 -type f -executable \( -name "${try_name}" -o -name "${PACKAGE}" \) 2>/dev/null | head -1)
      [[ -n "$found" ]] && BINARIES=("$found")
    fi
    if [[ ${#BINARIES[@]} -eq 0 ]]; then
      found=$(find "${PROFILE_DIR}" -maxdepth 1 -type f -executable ! -name "*.so" ! -name "*.rlib" 2>/dev/null | head -1)
      [[ -n "$found" ]] && BINARIES=("$found")
    fi
  fi
fi

if [[ ${#BINARIES[@]} -eq 0 ]]; then
  echo "No binary found. Check Cargo.toml [package] name and [[bin]] if used." >&2
  exit 1
fi

# Copy all binaries to output and build launch.toml (at root of buildpack layers dir)
mkdir -p "${OUTPUT_DIR}/bin"

first=true
for BINARY in "${BINARIES[@]}"; do
  [[ -z "$BINARY" || ! -f "$BINARY" ]] && continue
  BIN_NAME=$(basename "$BINARY")
  cp "$BINARY" "${OUTPUT_DIR}/bin/${BIN_NAME}"
  chmod +x "${OUTPUT_DIR}/bin/${BIN_NAME}"
  # Process type: "web" for first (default), else short name (e.g. backend, frontend)
  if [[ "$first" == true ]]; then
    proc_type="web"
    first=false
  else
    # e.g. dioxus-app-backend -> backend, dioxus-app-frontend -> frontend
    proc_type=$(echo "$BIN_NAME" | sed -E 's/^[^-]*-[^-]*-([^-]+)$/\1/')
    [[ "$proc_type" == "$BIN_NAME" ]] && proc_type="${BIN_NAME%.*}"
  fi
  if [[ -s "${LAYERS_DIR}/launch.toml" ]]; then
    echo "" >> "${LAYERS_DIR}/launch.toml"
  fi
  default_line=""
  [[ "$proc_type" == "web" ]] && default_line="default = true"
  cat >> "${LAYERS_DIR}/launch.toml" << LAUNCH
[[processes]]
type = "${proc_type}"
command = ["bin/${BIN_NAME}"]
${default_line}
LAUNCH
done

# Copy public/ for Dioxus fullstack (backend looks for it next to binary or in workspace)
APP_ROOT="${BUILD_DIR}/${WORKSPACE_DIR}"
if [[ -d "${APP_ROOT}/public" ]]; then
  # Dioxus server looks for public relative to binary (bin/public) or workspace root
  mkdir -p "${OUTPUT_DIR}/bin"
  CANON_APP=$(cd "${APP_ROOT}" 2>/dev/null && pwd -P)
  CANON_OUT=$(cd "${OUTPUT_DIR}" 2>/dev/null && pwd -P)
  if [[ "${CANON_APP}" != "${CANON_OUT}" ]]; then
    cp -r "${APP_ROOT}/public" "${OUTPUT_DIR}/"
  fi
  # Ensure bin/public exists (Dioxus looks next to executable)
  if [[ ! -d "${OUTPUT_DIR}/bin/public" ]]; then
    cp -r "${APP_ROOT}/public" "${OUTPUT_DIR}/bin/"
  fi
  echo "Copied public/ for Dioxus"
fi

# Write manifest for per-package image tooling (one binary per line)
for b in "${BINARIES[@]}"; do basename "$b"; done > "${OUTPUT_DIR}/.rust-binaries" 2>/dev/null || true

# Remove target/ and .cargo/ from workspace so they are not exported (saves ~1.5GB)
for dir in "${TARGET_DIR}" "${BUILD_DIR}/target" "${MANIFEST_DIR}/target" "${BUILD_DIR}/.cargo" "${MANIFEST_DIR}/.cargo"; do
  if [[ -d "${dir}" ]]; then
    rm -rf "${dir}"
    echo "Removed $(basename "${dir}")/ from output"
  fi
done

echo "Rust build complete (${PROFILE}): ${#BINARIES[@]} binary(ies) -> bin/"
